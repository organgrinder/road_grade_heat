
<!DOCTYPE html>
<html>
<head>
<title>Color-Coded Road Grade</title>
<meta name="description" content="Streets color-coded by grade." />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />


<script src="http://maps.googleapis.com/maps/api/js?sensor=true&libraries=geometry,places"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="resources/infobox_packed.js"></script>

<script type="text/javascript">

// XXX

// Declare map and overlay elements
var isMobile;
var map;
var locMarker;
var infoWindow;
var markerCircles = [];
var gradeLines = [];
var data = "";

var atlas = {
	lines: [],
	elevationPoints: {},
};

// Each object in gradeLines[] will have the following components:
// - obj (Google Polyline)
//		Actual object that's overlayed on the map, constructed from path in the JSON file
// - grade (float)
//		grade of the line, from the JSON file
// - highLatLng (Google LatLng)
// - lowLatLng (Google LatLng)
//		LatLngs for the high and low endpoints of the grade line
//		Pulling these from the array seems faster than using obj.getPath().getAt(x)
// - uphill (bool)
//		Records whether the grade line is currently rendered as uphill or downhill
//		This speeds up the refreshing by letting us update grade line styles selectively
// - onscreen (bool)
//		Records whether the grade line is currently visible within the viewport
//		This speeds up the refreshing by letting us update grade line styles selectively

var initialMapZoom = 14;
var initialMapType = 'map';
var initialMapCenter = new google.maps.LatLng(37.7915, -122.4345);
var initialMarkerPosition = new google.maps.LatLng(37.7815, -122.4345);
var markerCircleRadiuses = [50, 130, 230, 350]; // radiuses in meters at zoom level 15, automatically scaled
var markerCircleOpacities = [0.12, 0.06, 0.04, 0.025];

var SF_BOUNDS = new google.maps.Polygon({
	paths: [
		new google.maps.LatLng(37.7034, -122.3514),
		new google.maps.LatLng(37.8149, -122.3514),
		new google.maps.LatLng(37.8149, -122.5192),
		new google.maps.LatLng(37.7034, -122.5192),
	],
});


function initialize() {

	parseHashParams();
	$('#header').show();
	$('#control_box').show();
	
	setUpMap();
	
	// loadData(); // not currently hooked up to load anything
	// loadJSON(data);
	updateGradeLineVisibility();
	activateGradeLines();

	// this works to load data into var json
	var filename = "data/all_sf_paths.txt"

	loadFileAsJSON(filename, null, function(json) {
		console.log("loaded paths - 11880");
		drawNewLines(json);
	});
	
	// var json = { "paths":
	// [
	// [[-122.4165852,37.7990234],[-122.417312,37.798942]],
	// 	[[-122.4001293,37.7742804],[-122.4001388,37.7742461],[-122.4001333,37.7742142],[-122.4001105,37.7741835],[-122.3995073,37.7736879],[-122.3994179,37.7736238]],
	// 	[[-122.4001293,37.7742804],[-122.3994256,37.7748305],[-122.3979976,37.7759585],[-122.3957703,37.7777178]],
	// 	[[-122.3927587,37.7695725],[-122.3910999,37.7696681]],
	// 	[[-122.3957518,37.770518],[-122.3955519,37.7705266],[-122.394846,37.7705568]],
	// 	[[-122.411858,37.805361],[-122.413516,37.805152]],
	// [[-122.3989746,37.7171989],[-122.3994062,37.7189074]]
	// ]
	// };
	// drawNewLines(json);
}


function parseHashParams() {
	// needs: initialMapZoom, initialMapType, initialMapCenter, initialMarketPosition	

	if (window.location.hash == '')
		return;	
	var hash = window.location.hash.substr(1).split('/');
	
	// First check for existence of each parameter and put into correct data type
	var z = hash[0] ? parseInt(hash[0]) : '';
	var t = hash[1] ? hash[1] : '';
	var m_lat = hash[2] ? parseFloat(hash[2]) : '';
	var m_lng = hash[3] ? parseFloat(hash[3]) : '';
	var c_lat = hash[4] ? parseInt(hash[4]) : '';
	var c_lng = hash[5] ? parseInt(hash[5]) : '';

	if (isNaN(z) || isNaN(m_lat) || isNaN(m_lng) || isNaN(c_lat) || isNaN(c_lng)) {
		err();
		return;
	}
	if (! (t == 'map' || t == 'terrain' || t == 'satellite')) {
		err();
		return;
	}
	
	// // Satellite imagery not included in mobile interface, so use terrain instead
	// if (isMobile && t == 'satellite')
	// 	t = 'terrain';
	
	var m = new google.maps.LatLng(m_lat, m_lng);
	var c = new google.maps.LatLng(m_lat-c_lat/10000, m_lng-c_lng/10000);
	var cdb = google.maps.geometry.spherical.computeDistanceBetween;	
	
	// If either latlng is greater than 50 km from SF, probably an error
	if ((cdb(m, initialMapCenter) > 50000) || (cdb(c, initialMapCenter) > 50000)) {
		err();
		return;
	}
		
	initialMapZoom = z;
	initialMapType = t;
	initialMarkerPosition = m;
	initialMapCenter = c;
	
	function err() {
		window.location.hash = 'error_loading_link';
	}
}

function setUpMap() {
	// needs: map, initialMapZoom, initialMapType, initialMapCenter

	var mapStyles = [ 
		{featureType: 'landscape.man_made', elementType: 'geometry.fill', stylers: [{color: '#f8f1e3'}] },
		{featureType: 'water', elementType: 'geometry.fill', stylers: [{ color: '#a5bfdd'}] },
		{featureType: 'poi', stylers: [{visibility: 'off'}] },
		{featureType: 'poi.park', elementType: 'geometry.fill', stylers: [{visibility: 'on'}, {color: '#d9e8bd'}] },
		{featureType: 'transit', stylers: [{visibility: 'off'}] },
		{featureType: 'transit.station.rail', stylers: [{visibility: 'on'}] },
		{featureType: 'road', elementType: 'geometry.fill', stylers: [{color: '#ffffff'}] },
		{featureType: 'road', elementType: 'geometry.stroke', stylers: [{lightness: 40}] },
		{featureType: 'road', elementType: 'labels.icon', stylers: [{visibility: 'off'}] },
		{featureType: 'road', elementType: 'labels.text.stroke', stylers: [{color: '#ffffff'}] },
		{featureType: 'road.highway.controlled_access', 
			elementType: 'geometry.fill', stylers: [{color: '#fbc042'}, {lightness: 70}] },
	];

	var customMapType = new google.maps.StyledMapType(mapStyles, {name: 'Map'});
	
	// this is just to translate the initialMapType shorthand into the real identifiers
	var mapTypes = {
		map: 'Map', 
		terrain: google.maps.MapTypeId.TERRAIN, 
		satellite: google.maps.MapTypeId.SATELLITE,
	};
	
	var mapTypeIds = isMobile ? 
		[mapTypes.map, mapTypes.terrain] :
		[mapTypes.map, mapTypes.terrain, mapTypes.satellite];
	
    var mapOptions = {
		zoom: initialMapZoom,
		center: initialMapCenter,
		scaleControl: true,
		streetViewControl: false,
		mapTypeId: mapTypes[initialMapType],
		mapTypeControlOptions: {
        	mapTypeIds: mapTypeIds,
        }
	};

	map = new google.maps.Map(document.getElementById('map_canvas'), mapOptions);
	map.mapTypes.set('Map', customMapType);
	
	google.maps.event.addListener(map, 'idle', function() {
		// this picks up 'dragend', 'zoom_changed', AND the initial map load
		// maybe can simplify this if there's an event for initial map load...
		updateGradeLineVisibility();
	});
	google.maps.event.addListener(map, 'click', function() {
		if (infoWindow)
			infoWindow.close();
	});
	
	// Draw boundary line at the south edge of SF
	var boundary = new google.maps.Polyline({
		map: map,
		path: [
			new google.maps.LatLng(37.7083, -122.3932),
			new google.maps.LatLng(37.7083, -122.5023)
		],
		clickable: false,
		strokeColor: 'black',
		strokeOpacity: 0.3,
		strokeWeight: 2,
	});
}

function loadFileAsJSON(filename, cache, callback) {
	$.ajax({
		url: filename,
		async: true,
		success: function(result) {
			callback(JSON.parse(result));
		}
	});
}

function drawNewLines(json) {

	atlas.lines = json["paths"];

	// find the points we need elevations for
	var elevationLocations = [];
	for (var i=0; i<atlas.lines.length; i++) {
		var path = [];
		
		for (var j=0; j<atlas.lines[i].length; j++) {

			var currLocation = new google.maps.LatLng(atlas.lines[i][j][1], atlas.lines[i][j][0]);
			path[j] = currLocation;

			var opacity = 1;
			var g = google.maps.geometry.spherical;			

			if (
				j != 0 && 
				j != atlas.lines[i].length - 1 &&
				g.computeDistanceBetween(currLocation, path[j-1]) < 50
			) {
				opacity = .3;
			} else {
			 	elevationLocations.push(currLocation);
			}
		}
		// polyline = new google.maps.Polyline({
		// 	path: path,
		// 	strokeColor: 'rgba(0, 255, 255, 1)',
		// 	strokeOpacity: 1.0,
		// 	strokeWeight: 2,
		// });
		// polyline.setMap(map);
	}
	
	// get the elevations, and draw colored lines
	
	var localElevations = {
		"3771720-12239897": 50.94808959960938,
		"3776957-12239276": 3.972600221633911,
		"3776967-12239110": 3.183050394058228,
		"3777052-12239575": 2.27886962890625,
		"3777056-12239485": 1.897388219833374,
		"3777362-12239942": 2.267303705215454,
		"3777369-12239951": 2.197688817977905,
		"3777428-12240013": 2.596995830535889,
		"3777483-12239943": 2.322032451629639,
		"3777596-12239800": 2.824247598648071,
		"3777772-12239577": 2.774317979812622,
		"3779894-12241731": 88.49583435058594,
		"3779902-12241659": 84.73086547851562,
		"3780515-12241352": 3.976815223693848,
		"3780536-12241186": 3.950528621673584,
	}
	
	// DO IT using sample from this file
	// atlas.elevationPoints = localElevations;
	// drawElevations();
	
	// DO IT using data loaded from external file
	var filename = "data/elevations_some.txt"

	loadFileAsJSON(filename, null, function(json) {
		console.log("loaded elevations for paths whoo hoo with arrows")
		atlas.elevationPoints = json;
		drawElevations();
	});
	
	
	// DO IT using google call
	// getGoogleElevations(elevationLocations);
}

function getGoogleElevations(elevationLocations){
	
	elevator = new google.maps.ElevationService();

	var positionalRequest = { 'locations': elevationLocations }
	console.log("size: " + elevationLocations.length);
	
	elevator.getElevationForLocations(positionalRequest, function(results, status) {
		if (status != google.maps.ElevationStatus.OK) {
			// something went wrong with the elevation request
			console.log("problem with request");
			console.log(status);
		} else {
			for (var i=0; i<results.length-1; i++) {
				// console.log(results[i]);
				var lat = Math.round(results[i].location['A'] * 100000);
				var lng = Math.round(results[i].location['F'] * 100000);
				var key = "" + lat + lng;
				// console.log("creating array with key" + key);
				atlas.elevationPoints[key] = results[i].elevation;
			}
			drawElevations();
		}
		console.log(atlas.elevationPoints);
		// console.log("first point: " + atlas.elevationPoints[0].location + "elev:" + atlas.elevationPoints[0].elevation);
	});
}

function drawElevations() {
	// draw the elevations on map
	for (var i=0; i<atlas.lines.length; i++) {
		
		var segmentPath = [];

		var prevLocation = new google.maps.LatLng(atlas.lines[i][0][1], atlas.lines[i][0][0]);
		
		segmentPath.push(prevLocation);

		var lat = Math.round(prevLocation.lat() * 100000);
		var lng = Math.round(prevLocation.lng() * 100000);
		var key = "" + lat + lng;
		var segmentStartElev = atlas.elevationPoints[key];

		var segmentPathDistance = 0;

		var segmentEndElev;
		var currLocation;

		var geometry = google.maps.geometry.spherical;			
		
		// traverse the edge
		for (var j=1; j<atlas.lines[i].length; j++) {
			var currLocation = new google.maps.LatLng(atlas.lines[i][j][1], atlas.lines[i][j][0]);
			
			segmentPath.push(currLocation);
			
			var currDistance = geometry.computeDistanceBetween(currLocation, prevLocation);
			segmentPathDistance += currDistance;
			
			if (currDistance > 50 || j == atlas.lines[i].length - 1) {
				
				var lat = Math.round(currLocation.lat() * 100000);
				var lng = Math.round(currLocation.lng() * 100000);
				var key = "" + lat + lng;
				segmentEndElev = atlas.elevationPoints[key];

				var segmentGain = Math.abs(segmentEndElev - segmentStartElev);				
				var segmentGrade = (segmentGain / segmentPathDistance);
				
				var palatte = [		
					// 'rgba(0, 255, 0, 0)',
					'rgba(0, 255, 0, 1)',
					'rgba(255, 255, 0, 1)',
					'rgba(255, 0, 0, 1)',
					'rgba(0, 0, 255, 1)',
					'rgba(255, 255, 255, 1)',
				]
	
				var perct = Math.min(segmentGrade, .15) / .15;
				var selector = Math.floor(perct * (palatte.length))
				var color = palatte[selector];

				polyline = new google.maps.Polyline({
					path: segmentPath,
					strokeColor: color,
					strokeOpacity: 1.0,
					strokeWeight: 3,
				});
				polyline.setMap(map);

				segmentStartElev = segmentEndElev;
				segmentPath = [];
				segmentPath.push(currLocation);
				// console.log("reset path: " + segmentPath)
				segmentPathDistance = 0;
				
			} else {								
					// 			    var marker = new google.maps.Marker({
					// 			        position: currLocation,
					// opacity: 0.3,
					// 			        map: map,
					// title: "dist: " + currDistance,
					// 			    });
			}
			
			var prevLocation = currLocation;
			
			// test code that just shows markers, doesn't show elevation colors
			// if (
			// 	j != 0 &&
			// 	j != lines[i].length - 1 &&
			// 	g.computeDistanceBetween(currLocation, path[j-1]) < 50
			// ) {
			// 	opacity = .3;
			// 	title = "fade";
			// } else {
			// 	var lat = Math.round(lines[i][j][1] * 100000);
			// 	var lng = Math.round(lines[i][j][0] * 100000);
			// 	var key = "" + lat + lng;
			// 	console.log("key when looking up" + key);
			// 	title = "" + atlas.elevationPoints[key];
			// }
			//
			// 		    var marker = new google.maps.Marker({
			// 		        position: currLocation,
			// 		        map: map,
			// 	opacity: opacity,
			// 	title: title,
			// 		    });


			// var distance = g.computeDistanceBetween(markerLatLng, gradeLines[i].highLatLng);
			
		}
	}
}

function loadJSON(json) {
	// needs: gradeLines

// XXX - turn old lines on/off
	
	if (json == null || json == "") return
			
	var t = new Date().getTime();
	var minGrade = 100;
	var maxGrade = 1;
	for (var i=0, l=json.features.length; i<l-1; i++) {
		var f = {};
		var path = google.maps.geometry.encoding.decodePath(json.features[i][0]);
		f.obj = new google.maps.Polyline({path: path});
		f.grade = json.features[i][1];
		
		var palatte = [		
			// 'rgba(0, 255, 0, 0)',
			'rgba(0, 255, 0, 1)',
			'rgba(255, 255, 0, 1)',
			'rgba(255, 0, 0, 1)',
			// 'rgba(0, 0, 255, 1)',
			'rgba(255, 255, 255, 1)',
		]
		
		// min(.2, .3) / .3
		// floor [% * (count-1)]
		
		// f.grade is out of 100, not 1
		
		minGrade = Math.min(minGrade, f.grade);
		maxGrade = Math.max(maxGrade, f.grade);
		
		var perct = Math.min((f.grade-5), 15) / 15;
		var selector = Math.floor(perct * (palatte.length))
		var color = palatte[selector];
		
		f.obj.setOptions({
			strokeOpacity: 0.0,
			strokeWeight: 5,
			strokeColor: color,
		});
		var d = json.features[i][2];
		f.lowLatLng = path[d * (path.length-1)];
		f.highLatLng = path[(1-d) * (path.length-1)];
		f.onscreen = true; // default in case data loads more quickly than the map viewport
		gradeLines.push(f);
	}
	// console.log('min: ' + minGrade + 'max: ' + maxGrade);
	// console.log('count: ' + json.features.length);
	// console.log('loadJSON: ' + (new Date().getTime() - t) + ' ms');
}

function updateGradeLineVisibility() {
	// needs: gradeLines[]
		
	// This runs at initialization and whenever the viewport bounds are changed

	if (! map.getBounds())
		return;
	
	var t = new Date().getTime();
	var b = map.getBounds();	
	for (var i=0, l=gradeLines.length; i<l; i++) {
		var s = gradeLines[i];
		s.onscreen = true;
		// s.onscreen = (b.contains(s.highLatLng) || b.contains(s.lowLatLng));
	}
	// console.log('updateVisibility: ' + (new Date().getTime() - t) + ' ms');
}

function activateGradeLines(override) {
	// needs: map, gradeLines
	
	// This runs at initialization only. The majority of the initialization time goes to 
	// linking the gradeLines to the map. So if the viewport bounds have loaded already, we 
	// can speed things up by only linking the visible lines, and linking the others later.

	var t = new Date().getTime();
	var count = 0;

	for (var i=0, l=gradeLines.length; i<l; i++) {
		if ((! override) && (! gradeLines[i].onscreen))
			continue;
		count ++;
		gradeLines[i].obj.setMap(map);
	}
	var s = override ? ' (full map)' : '';
	// console.log('activateGradeLines: ' + (new Date().getTime() - t) + ' ms, ' + count + ' lines' + s);
}

function addGradeLineListeners() {
	var t = new Date().getTime();
	for (var i=0, l=gradeLines.length; i<l; i++) {
		// Because listeners are added inside a loop, we have to create the callbacks
		// using an outside function so that each has the correct closures.
		google.maps.event.addListener(gradeLines[i].obj, 'click', makeGradeLineCallback(gradeLines[i].grade));
	}
	// console.log('addGradeLineListeners: ' + (new Date().getTime() - t) + ' ms');
}

function makeGradeLineCallback(grade) {
	return function(e) {
		makeGradeLabel(grade, e.latLng);
	};
}

function makeGradeLabel(grade, latLng) {
	// needs: map, infoWindow
	if (infoWindow)
		infoWindow.close();
	var msg = '' + grade.toFixed(1) + '%&nbsp;grade';
	var style = {
		background: '#FFF', 
		width: '76px', 
		opacity: '0.8',
		padding: '2px',
		border: '1px solid #CCC',
		'font-family': 'Helvetica, sans-serif',
		'font-size': '12px',
		'text-align': 'center',
	};
	infoWindow = new InfoBox({
		content: msg, 
		position: latLng, 
		boxStyle: style, 
		closeBoxURL: '',
		enableEventPropagation: true,
		alignBottom: true,
		pixelOffset: new google.maps.Size(-38, 0),
	});
	infoWindow.open(map);
}

function retrieveLocMarker() {
	// needs: map, locMarker
	locMarker.setPosition(map.getCenter());
}

function customAlert(s) {
	if (isMobile)
		alert(s)
	else {
		$('#alert-left').html(s);
		// calculate offset to center 'OK' button: 
		//    box height minus padding, minus button height, divided by 2, minus an adjustment
		var offset = ($('#alert').innerHeight() - 20 - $('#alert-ok').innerHeight()) / 2 - 2;
		$('#alert-right').css('padding-top', offset);
		$('#alert').center();
		$('#alert').show();
		$('#alert-ok').focus();
	}
}

function tryGeolocation(initial) {
	// needs: map, locMarker
	//   and if initial=true: initialMapCenter, initialMarkerPosition, initialMapZoom
	if(navigator.geolocation)
    	navigator.geolocation.getCurrentPosition(geoSetMap, fail);
    else
    	fail();
    	
    function geoSetMap(pos) {
	    var latlng = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
		if (! google.maps.geometry.poly.containsLocation(latlng, SF_BOUNDS)) {
			var s = isMobile ? 
				"It looks like you're outside of Hill Mapper's coverage area — currently limited to the city of San Francisco — but you can still explore the map." :
				"It looks like you're outside of Hill Mapper's coverage area, which is currently limited to the city of San Francisco.";
		    customAlert(s)
			return;
		}
		setLocation(latlng);
    }
    
    function fail(e) {
    	var s = isMobile ?
    		"Unable to detect your location. You can still explore the map, or reload the page to try again." :
    		"Unable to detect your location.";
	    customAlert(s);
    }
}

function setLocation(latlng) {
	if (map) {
	    map.setCenter(latlng);
	    map.setZoom(16);
	    locMarker.setPosition(latlng);
	}
	else {
		initialMapCenter = latlng;
		initialMapZoom = 16;
		initialMarkerPosition = latlng;
	}
}


// jQuery code for the HTML elements:

// from http://archive.plugins.jquery.com/project/autocenter
(function($){
    $.fn.extend({
        center: function () {
            return this.each(function() {
                var top = ($(window).height() - $(this).outerHeight()) / 2;
                var left = ($(window).width() - $(this).outerWidth()) / 2;
                $(this).css({position:'absolute', margin:0, top: (top > 0 ? top : 0)+'px', left: (left > 0 ? left : 0)+'px'});
            });
        }
    }); 
})(jQuery);


function loadData() {
	// load data from data/crappy_data.txt
}


$(document).ready(function(){

	$("#hide").click(function() {
		$(".descript").hide();
		$(".instructions").hide();
		$(this).hide();
		$("#show").show();
	});

	$("#show").click(function() {
		$(".descript").show();
		$(".instructions").show();
		$(this).hide();
		$("#hide").show();
	});
	
	$('#link_generator').mouseover(function() {
		$(this).attr('href', generateLink());
	});
	
	$('a.marker_retriever').click(function() {
		retrieveLocMarker();
	});
	
	$('a.location_detector').click(function() {
		tryGeolocation();
	});
	
	$('a.instruction_viewer').click(function() {
		$('#instructions_mobile').show();
	});
	
	$('div#instructions_mobile').click(function() {
		$('#instructions_mobile').hide();
	});
	
	$('#alert-ok').click(function() {
		$('#alert').hide();
	});
	
	$('#alert-ok').keydown(function(e) {
		if(e.keyCode == 13) // this is the 'enter' key
			$('#alert').hide();
	});

});


</script>

<!-- Google Analytics -->
<script>
  // (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  // (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  // m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  // })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  // ga('create', 'UA-42777617-1', 'hillmapper.com');
  // ga('send', 'pageview');
</script>

</head>
<body onLoad="initialize()">

  <div id="header">
  <div id="header_left">HILL MAPPER SAN FRANCISCO</div>
  <div id="header_twitter">
<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://hillmapper.com/"></a>
<a href="https://twitter.com/hillmapper" class="twitter-follow-button" data-show-count="false"></a>
  </div>
  <div id="header_facebook">
<div class="fb-like" data-href="http://hillmapper.com/" data-width="100" data-layout="button_count" data-show-faces="false" data-send="false"></div>
  </div>
  </div>
  
  <div id="map_canvas"></div>

  <div id="control_box">
  	<div class="descript">Colors show which streets are steeper than others.</div>
  	<ol class="instructions">
  	<li>Red streets are steep. Blue streets are shallow.</li>
  	<li>Unshaded streets are flat.</li>
	</ol>
  	<hr class="instructions">

  	<div id="detect">
  		<a class="location_detector">Detect location</a><br></div>
  	<div id="footer">Made in San Francisco</div>

  </div>

  <div id="alert">
	  <div id="alert-left"></div>
	  <div id="alert-right"><input id="alert-ok" type="submit" value="OK"></div>
  </div>
  
  <div id="control_box_mobile">
  	<div class="action_mobile">
  		&bull; <a class="instruction_viewer">INSTRUCTIONS</a></div>
  	<div class="action_mobile">
  		&bull; <a class="marker_retriever">Retrieve marker</a></div>
  	<div class="action_mobile">
  		&bull; <a class="location_detector">Update location</a></div>
  </div>
  
  <div id="instructions_mobile">
    	<div>Colors show which streets go uphill or downhill when you approach them from the stick-figure location marker.</div>
  	<ol class="mobile">
  	<li>Red streets go uphill. Blue streets go downhill.</li>
  	<li>The darker the color, the steeper the hill. Unshaded streets are flat.</li>
  	<li>Try moving the marker or updating your location to redraw the terrain.</li>
  	</ol>
  </div>
  
</body>
</html>
